---
---

# how bodies matter

The human body has skill and dexterity which digital interaction techniques do
not full take advantage of. The mental modal of the ideal user of a GUI would
be that of a massive eye and finger. Five key concepts are introduced when can
be used as generative and evaluative design tools when considering interactive
technology. They are: thinking through doing, performance, visibility, risk,
and thickness of practice. People gesture not only to commmunicate but also to
lighten the mental load they are under. For example, mouthing out these words
as I am typing them refines my sense of my own voice.

# readwear editwear

jim hollan draws on schoen's theory of interfaces prompting a reflective
conversation for shaping problem-setting, which lies at the heart of
professional work, rather than many applications which instead focus on
problem-solving, and therefore already harden the context in which the problem
is framed. he embeds the wear of the document into the scrollbar of a zmacs
editor, and gives other examples of how wear could be implemented into existing
interface elements, essentially creating the data for a heatmap of where the
interface is being used. the great things is that it does not require any
additional action by the user - essentially it comes 'free', though there are
issues of privacy and data ownership when it comes to the actual usage data.

# the computer for the 21st century

mark weiser introduces the concept of the computer for the 21st century by
introducing pads, tabs, and boards. these would be cheap, almost disposable
sources of computation that would lie in our environment in the same way that
writing is embedded into the world around us. he imagines embedded virtuality:
drawing the computer into the world, rather than simply creating a new world
and then drawing the user into it, which disrupts and isolates the communities
and workplaces that we operate inside of.

# groupware: challenges for developers

jonathan grudin, '94, presents 8 challenges for developers. separations exist
between orgs, groups, and users, and software applications for each of these
vary greatly, along with the issues faces while developing them, and even
beyond development to acceptance. grudin specifically presents the central
challenges that groupware developers face. first there was software for orgs,
than users, and now groups. because individuals act with a groupware
application, it has all the interface design challenges along with new
challenges stemming from its involvement in group processes. groupware at the
time of writing: email, bboard. 8 main challenges, work/benefit disparity,
critical mass, social process disruption, exception handling, unobtrusive
accessibility, evaluation difficulty, intuition failure, hard adoption. But!
There is hope... while considering a new, 'work' perspective.

# contextual inquiry ch3

TODO

# direct manipulation interfaces

TODO

# nielsen's 10 characteristics

source: https://www.nngroup.com/articles/ten-usability-heuristics/

- Visibility of system status: The system should always keep users informed about what is going on, through appropriate feedback within reasonable time.
- Match between system and the real world: The system should speak the users' language, with words, phrases and concepts familiar to the user, rather than system-oriented terms. Follow real-world conventions, making information appear in a natural and logical order.
- User control and freedom: Users often choose system functions by mistake and will need a clearly marked "emergency exit" to leave the unwanted state without having to go through an extended dialogue. Support undo and redo.
- Consistency and standards: Users should not have to wonder whether different words, situations, or actions mean the same thing. Follow platform conventions.
- Error prevention: Even better than good error messages is a careful design which prevents a problem from occurring in the first place. Either eliminate error-prone conditions or check for them and present users with a confirmation option before they commit to the action.
- Recognition rather than recall: Minimize the user's memory load by making objects, actions, and options visible. The user should not have to remember information from one part of the dialogue to another. Instructions for use of the system should be visible or easily retrievable whenever appropriate.
- Flexibility and efficiency of use: Accelerators — unseen by the novice user — may often speed up the interaction for the expert user such that the system can cater to both inexperienced and experienced users. Allow users to tailor frequent actions.
- Aesthetic and minimalist design: Dialogues should not contain information which is irrelevant or rarely needed. Every extra unit of information in a dialogue competes with the relevant units of information and diminishes their relative visibility.
- Help users recognize, diagnose, and recover from errors: Error messages should be expressed in plain language (no codes), precisely indicate the problem, and constructively suggest a solution.
- Help and documentation: Even though it is better if the system can be used without documentation, it may be necessary to provide help and documentation. Any such information should be easy to search, focused on the user's task, list concrete steps to be carried out, and not be too large.

# radical atoms

TODO but not actually on the list
